<!-- <!DOCTYPE html> -->
<html>
<head>
	<title>Interactive Atomistic Environment</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #f0f0f0;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script src="js/libs/three.js"></script>
	<script src="js/controls/TrackballControls.js"></script>
	<script src='js/libs/dat.gui.min.js'></script>
    <script src="network.js"></script>
	<script>
		var container;
		var camera, controls, scene, renderer;
		var optionController;
		var timestep;
		var energyVal = 0;
		var systemOption;
		var objects = [];
		var plane = new THREE.Plane();
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2(),
		offset = new THREE.Vector3(),
		intersection = new THREE.Vector3(),
		INTERSECTED, SELECTED, 
		systemName = "H2",
		system = systems[systemName], // which system to show, Water, Hydrogen, Oxygen 
        energyHistory = [];
		init();
		animate();

		function init() {
			container = document.createElement( 'div' );
			document.body.appendChild( container );
			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.z = 1000;
			scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0x505050 ) );
			var light = new THREE.SpotLight( 0xffffff, 1.5 );
			light.position.set( 0, 500, 2000 );
			scene.add( light );


		    var atomList = system.getNodeList();

			atomList.forEach(function(node){
				node.atom.name = "atom:" + node.aid;
				node.atom.moleculeName = node.name
				console.log(node)
				scene.add(node.atom);
				objects.push(node.atom)

				node.edges.forEach(function(edge){
					if(edge.getVisited() == false){
						var lineGeo = new THREE.Geometry()
						var lineMaterial = new THREE.LineBasicMaterial({ color: 0xAAAAAA, linewidth: 50 })
						
						lineGeo.vertices.push(edge.atom1.position)
						lineGeo.vertices.push(edge.atom2.position)
						var line = new THREE.LineSegments(lineGeo, lineMaterial);
						
						line.name = "line:" + edge.atom1.aid + ":" + edge.atom2.aid
					    
					    scene.add(line)
					    // objects.push(line)
					    edge.setVisited()
					}
				})
			})

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.sortObjects = false;
			container.appendChild( renderer.domElement );

			// placing title
			var title = document.createElement( 'div' );
			title.style.position = 'absolute';
			title.style.top = '10px';
			title.style.textAlign = 'center';
			title.style.width = '100%';
			title.innerHTML = 'Interactive Atomistic Environment for ' + systemName;
			
			// placing energy marker
			var energy = document.createElement( 'div' );
			energy.style.position = 'absolute';
			energy.style.bottom = '10px';
			energy.style.textAlign = 'left';
			energy.style.width = '100%';
			energy.innerHTML = 'Energy (J): <span id="energyVal" ></span>';

			// placing 'on' marker
			var text = document.createElement( 'div' );
			text.style.position = 'absolute';
			text.style.bottom = '30px';
			text.style.textAlign = 'left';
			text.style.width = '100%';
			text.innerHTML = 'On: <span id="moleculeName" ></span>';

			container.appendChild( title );
			container.appendChild( energy );
			container.appendChild( text );

			setupOptions()

			renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
			renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
			renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

			controls = new THREE.TrackballControls( camera, renderer.domElement );
			controls.rotateSpeed = 7.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function setupOptions() {
			// initializing options
			optionController = {
				timestep: 0.05,
				systemOption: "H2"
				};

			var folder;
			var gui = new dat.GUI();
			
			// simulation controls
			folder = gui.addFolder( "Simulation Controls" );
			folder.add( optionController, "timestep", 0.01, 2.0, 0.01 ).name( "Timestep (s)" ).onChange( render );
			
			// setup system
			folder = gui.addFolder( "Setup System" );
			folder.add( optionController, "systemOption", [ "H2", "O2", "H2O", "Option4", "Option5", "Option6" ] ).name( "System" ).onChange( render );

			var buttonReset = {
			    resetSys: function() {
				resetSys();
			    }
			};
			folder.add( buttonReset, 'resetSys' ).name( "Reset System" );

			gui.close();
		}
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		function onDocumentMouseMove( event ) {
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			raycaster.setFromCamera( mouse, camera );
			if ( SELECTED ) {
				if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
					SELECTED.position.copy( intersection.sub( offset ) );
				}
				return;
			}
			var intersects = raycaster.intersectObjects( objects );
			if ( intersects.length > 0 ) {
				if ( INTERSECTED != intersects[ 0 ].object ) {
					if ( INTERSECTED ) 
						INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x754200 );
				}
				container.style.cursor = 'pointer';
	
				document.getElementById( 'moleculeName' ).innerText = INTERSECTED.moleculeName

				var ids = INTERSECTED.name.split(":")
					var id = ids[1]
					var node = system.getNode(id)
                    node.setPosition(INTERSECTED.position)

			} else {
				if ( INTERSECTED )
				INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
				INTERSECTED = null;
				container.style.cursor = 'auto';
				document.getElementById( 'moleculeName' ).innerText = ""
			}
		}
		function onDocumentMouseDown( event ) {
			event.preventDefault();
			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( objects );
			if ( intersects.length > 0 ) {
				controls.enabled = false;
				SELECTED = intersects[ 0 ].object;
				if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
					offset.copy( intersection ).sub( SELECTED.position );
				}
				container.style.cursor = 'move';
			}
		}
		function onDocumentMouseUp( event ) {
			event.preventDefault();
			controls.enabled = true;
			if ( INTERSECTED ) {
				setEnergy();
				SELECTED = null;
			}
			container.style.cursor = 'auto';
		}

		function animate(ts) { 
		    setTimeout(function () { 
		    requestAnimationFrame(animate); 
		    render();}
		    , 1000 / 25); // decrease the frame rate
		}

		function resetSys() {
			// does nothing yet
		}

		function updatePosition(){
            var objects = scene.children

			objects.forEach(function(obj){
				if(obj.type == "Mesh"){
					var ids = obj.name.split(":")
					var id = ids[1]
					var node = system.getNode(id)
                    obj.position.x = node.position.x
                    obj.position.y = node.position.y
                    obj.position.z = node.position.z
				}

				if(obj.type == "LineSegments"){
					var ids = obj.name.split(":")
				    var aid1 = ids[1], aid2 = ids[2]    
                    var atom1 = scene.getObjectByName("atom:" + aid1)
                    var atom2 = scene.getObjectByName("atom:" + aid2);
                    var p1 = atom1.position, p2 = atom2.position
                    var dist = p1.distanceTo(p2)

                    obj.geometry.vertices[0]= p1.clone()
                    obj.geometry.vertices[1]= p2.clone()

                    obj.geometry.verticesNeedUpdate = true

                    obj.material.opacity = dist > settings.opacityThresholdScale ? 0 : (1 - dist / settings.opacityThresholdScale)
                    obj.material.needsUpdate = true
                    obj.material.transparent = true
			    }
			})
			energyHistory.push(system.getEnergy())
			if(energyHistory.length < 500){ // keep only 500 history
				energyHistory.shift()
			}
			document.getElementById( 'energyVal' ).innerText = parseFloat(system.getEnergy()).toFixed(4);
		}
		

		function render() {
			updatePosition()
			controls.update();
			system.recomputeForceAcc()
			system.updateNodes()
			renderer.render( scene, camera );

		}
	</script>
</body>
</html>
