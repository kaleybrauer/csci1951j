<!-- <!DOCTYPE html> -->
<html>

<head>
    <title>Interactive Atomistic Environment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        background-color: #f0f0f0;
        overflow: hidden;
    }
    </style>
</head>

<body>
    <script src="js/libs/three.js"></script>
    <script src="js/controls/TrackballControls.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script src='js/libs/stats.min.js'></script>
    <script src="network.js"></script>
    <script>
    var container;
    var camera, controls, scene, renderer;
    var optionController;
    var timestep;
    var energyVal = 0;
    var systemOption;
    var objects = [];
    var plane = new THREE.Plane();
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
        offset = new THREE.Vector3(),
        intersection = new THREE.Vector3(),
        INTERSECTED, SELECTED;

    var systemName = "H2",
        system = systems[systemName], // which system to show 
        displayType = "position";

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.fillStyle = 'rgba(127, 127, 127, 0.3)';

    init();
    animate();

    // init the scene
    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);
        // camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        // camera.position.z = 500;
        camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 200;


        setupSystem();

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        container.appendChild(renderer.domElement);

        // placing title
        var title = document.createElement('div');
        title.style.position = 'absolute';
        title.style.top = '10px';
        title.style.textAlign = 'center';
        title.style.width = '100%';
        title.innerHTML = 'Interactive Atomistic Environment for ' + systemName;

        // placing energy marker
        var energy = document.createElement('div');
        energy.style.position = 'absolute';
        energy.style.bottom = '10px';
        energy.style.textAlign = 'left';
        energy.style.width = '100%';
        energy.innerHTML = 'Energy (J): <span id="energyVal" ></span>';

        // placing 'on' marker
        var text = document.createElement('div');
        text.style.position = 'absolute';
        text.style.bottom = '30px';
        text.style.textAlign = 'left';
        text.style.width = '100%';
        text.innerHTML = 'On: <span id="moleculeName" ></span>';

        canvas.width = settings.maxHistory;
        canvas.height = settings.maxHistory / 40;
        canvas.style.position = 'absolute';
        canvas.style.bottom = "15px";
        canvas.style.left = '150px';
        canvas.style.right = '10px';
        canvas.style.width = '100%';

        container.appendChild(title);
        container.appendChild(energy);
        container.appendChild(text);
        container.appendChild(canvas);

        setupOptions()

        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 7.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        window.addEventListener('resize', onWindowResize, false);
    }

    // set up which one to show
    function setupSystem() {
        objects = []
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0x505050));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light);

        var atomList = system.getNodeList();

        atomList.forEach(function(node) {
            node.atom.name = "atom:" + node.aid;
            node.atom.moleculeName = node.name
                // console.log(node)
            scene.add(node.atom);
            objects.push(node.atom)

            node.edges.forEach(function(edge) {
                // set up the bond
                if (edge.getVisited() == false) {
                    var lineGeo = new THREE.Geometry()
                    var lineMaterial = new THREE.LineBasicMaterial({
                        color: parameters.color.bond,
                        linewidth: parameters.bondwidth
                    })

                    lineGeo.vertices.push(edge.atom1.position)
                    lineGeo.vertices.push(edge.atom2.position)
                    var line = new THREE.LineSegments(lineGeo, lineMaterial);

                    line.name = "line:" + edge.atom1.aid + ":" + edge.atom2.aid

                    scene.add(line)
                    edge.setVisited()
                }
            })
        })
    }

    function setupOptions() {
        // initializing options
        optionController = {
            timestep: 0.05,
            systemOption: "H2", // which system we are showing
            displayOption: "position", // which display we are showing (in this case, position space)
            energyOpacity: true // whether or not the energy is encoded in the opacity
        };

        var folder;
        var gui = new dat.GUI();

        // simulation controls
        folder = gui.addFolder("Simulation Controls");
        folder.add(optionController, "timestep", 0.01, 2.0, 0.01).name("Timestep (s)").onChange(render);

        // display controls
        folder = gui.addFolder("Display");
        folder.add(optionController, "displayOption", ["position", "momentum", "energy"]).name("Display").onChange(render);
        folder.add(optionController, "energyOpacity").onChange(render);


        // setup system
        folder = gui.addFolder("Setup System");
        folder.add(optionController, "systemOption", ["H2", "O2", "H2O"]).name("System").onChange(render);

        var buttonReset = {
            resetSystem: function() {
                system.reset()
                settings.energyHistory = []
            }
        };
        folder.add(buttonReset, 'resetSystem').name("Reset System").onChange(render);

        gui.close();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                SELECTED.position.copy(intersection.sub(offset));
            }
            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED)
                    INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                plane.setFromNormalAndCoplanarPoint(
                    camera.getWorldDirection(plane.normal),
                    INTERSECTED.position);
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex(0x754200);
            }
            container.style.cursor = 'pointer';

            document.getElementById('moleculeName').innerText = INTERSECTED.moleculeName

            var ids = INTERSECTED.name.split(":")
            var id = ids[1]
            var node = system.getNode(id)
            node.setPosition(INTERSECTED.position)

        } else {
            if (INTERSECTED)
                INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            container.style.cursor = 'auto';
            document.getElementById('moleculeName').innerText = ""
        }
    }

    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object;
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                offset.copy(intersection).sub(SELECTED.position);
            }
            container.style.cursor = 'move';
        }
    }

    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            SELECTED = null;
        }
        container.style.cursor = 'auto';
    }

    function animate() {
        setTimeout(function() {
            requestAnimationFrame(animate);
            render();
        }, 1000 / 25); // decrease the frame rate

        var time = performance.now() / 1000;
        context.clearRect(0, 0, canvas.width, canvas.height);

        var maxEnergy = Math.max.apply(null, settings.energyHistory) // 4

        if (settings.energyHistory > 0)
            context.moveTo(0, canvas.height - canvas.height * settings.energyHistory[i] / maxEnergy);
        else
            context.moveTo(0, canvas.height);

        var x = 0,
            y = 0;
        context.beginPath();
        for (var i = 0; i < settings.energyHistory.length; i++) {
            x = i;
            if (maxEnergy == 0) {
                y = canvas.height - 1
            } else {
                y = canvas.height - 1 - (canvas.height - 2) * settings.energyHistory[i] / maxEnergy
            }

            context.lineTo(x, y);
        }
        context.stroke();

    }

    function updatePosition() {
        var objects = scene.children

        objects.forEach(function(obj) {
            if (obj.type == "Mesh") {
                var ids = obj.name.split(":")
                var id = ids[1]
                var node = system.getNode(id)

                if (displayType == "position") {
                    obj.position.x = node.position.x
                    obj.position.y = node.position.y
                    obj.position.z = node.position.z
                }

                //              	if (displayType == "momentum") {
                //               	    obj.position.x = (node.velocity.x * mass)
                //  	              	obj.position.y = (node.velocity.y * mass)
                //                		obj.position.z = (node.velocity.z * mass)
                //              	}

                // opacity corresponds to energy
                // NOTE --- need to put up a legend on the side so the user knows what opacity corresponds to what energy (will be dynamic)
                if (optionController.energyOpacity) {
                    if (node.maxEnergy != 0) {
                        obj.material.opacity = 0.2 + 0.9*node.energy/node.maxEnergy
                        console.log(node.energy)
                        console.log(node.maxEnergy)
                    }
                    if (node.maxEnergy == 0) {
                        obj.material.opacity = 1
                    }
                }
                // if the opacity = energy option is not selected
                if (!optionController.energyOpacity) {
                    obj.material.opacity = 1
                }        
                obj.material.needsUpdate = true
                obj.material.transparent = true

            }

            if (obj.type == "LineSegments") {
                var ids = obj.name.split(":")
                var aid1 = ids[1],
                    aid2 = ids[2]
                var atom1 = scene.getObjectByName("atom:" + aid1)
                var atom2 = scene.getObjectByName("atom:" + aid2);
                var p1 = atom1.position,
                    p2 = atom2.position
                var dist = p1.distanceTo(p2)

                obj.geometry.vertices[0] = p1.clone()
                obj.geometry.vertices[1] = p2.clone()

                obj.geometry.verticesNeedUpdate = true

                obj.material.opacity = dist > parameters[systemName].opacityThresholdScale ? 0 : (1 - dist / parameters[systemName].opacityThresholdScale)
                obj.material.needsUpdate = true
                obj.material.transparent = true
            }
        })
    }

    function render() {
        settings.timeStep = optionController.timestep

        if (systemName != optionController.systemOption) {
            systemName = optionController.systemOption
            system = systems[systemName]
            settings.energyHistory = []
            setupSystem();
        }
        updatePosition()
        controls.update();
        // only update forces and energies if an atom is not currently clicked on
        if (SELECTED != null) {
            system.selectID = SELECTED.name.split(':')[1]
            system.moveAtom(+system.selectID)
            system.setMaxEnergies()
        } else {
            // system energy
            settings.energyHistory.push(system.getEnergy())
            if (settings.energyHistory.length > settings.maxHistory) { // keep only 500 history
                settings.energyHistory.shift()
            }
            document.getElementById('energyVal').innerText = parseFloat(system.getEnergy()).toFixed(4);
            // forces & atom energy
            system.getForceAcc()
            system.updateNodes()
        }
        renderer.render(scene, camera);

    }
    </script>
</body>

</html>
