<!-- <!DOCTYPE html> -->
<html>

<head>
    <title>Interactive Atomistic Environment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        background-color: #f0f0f0;
        overflow: hidden;
    }
    </style>
</head>

<body>
    <script src="js/libs/three.js"></script>
    <script src="js/controls/TrackballControls.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script src='js/libs/stats.min.js'></script>
    <script src="network.js"></script>
    <script>
    var container;
    var camera, controls, scene, renderer, objects = [];
    var options = {
            timestep: 0.05,
            systemOption: "H2",         // which system we are showing
            displayOption: "position",  // which display we are showing (in this case, position space)
            "energy as opacity": false, // whether or not the energy is encoded in the opacity
            "momentum as vector": false
        };
    var energyVal = 0;
    var plane = new THREE.Plane();
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
        offset = new THREE.Vector3(),
        intersection = new THREE.Vector3(),
        INTERSECTED, SELECTED;

    var system = systems[options.systemOption]
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.fillStyle = 'rgba(127, 127, 127, 0.3)';

    init();
    animate();

   /************************************************************************************/
   /************************************************************************************/
   /************************************* init the scene  ******************************/
   /************************************************************************************/
   /************************************************************************************/

    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);
        // using orthographic camera
        camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 500;

        setupSystem();

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });

        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        container.appendChild(renderer.domElement);

        // placing title
        var title = document.createElement('div');
        title.style.position = 'absolute';
        title.style.top = '10px';
        title.style.textAlign = 'center';
        title.style.width = '100%';
        title.innerHTML = 'Interactive Atomistic Environment for ' + options.systemOption;

        // placing energy marker
        var energy = document.createElement('div');
        energy.style.position = 'absolute';
        energy.style.bottom = '10px';
        energy.style.textAlign = 'left';
        energy.style.width = '100%';
        energy.innerHTML = 'Energy (J): <span id="energyVal" ></span>';

        // placing 'on' marker
        var text = document.createElement('div');
        text.style.position = 'absolute';
        text.style.bottom = '30px';
        text.style.textAlign = 'left';
        text.style.width = '100%';
        text.innerHTML = 'On: <span id="moleculeName" ></span>';

        canvas.width = settings.maxHistory;
        canvas.height = settings.maxHistory / 40;
        canvas.style.position = 'absolute';
        canvas.style.bottom = "15px";
        canvas.style.left = '150px';
        canvas.style.right = '10px';
        canvas.style.width = '100%';

        container.appendChild(title);
        container.appendChild(energy);
        container.appendChild(text);
        container.appendChild(canvas);

        setupOptions();

        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 7.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        window.addEventListener('resize', onWindowResize, false);
    }

   /************************************************************************************/
   /************************************************************************************/
   /*************************** set up the system to show  ***************************/
   /************************************************************************************/
   /************************************************************************************/
    function setupSystem() {
        system = systems[options.systemOption]
        settings.energyHistory = []
        objects = []
        
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0x505050));

        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light);

        var atomList = system.getNodeList();

        // go through the list and add each node (atom) to the scene
        atomList.forEach(function(node) {
            node.atom.name = "atom:" + node.aid;
            node.atom.moleculeName = node.name
            scene.add(node.atom);
            objects.push(node.atom)

            // add the vector to show momentum but make it invisible
            var momentumGeo =  new THREE.Geometry()
            var lineMaterial =  new THREE.LineBasicMaterial({
                        color: parameters.color.momentum,
                        linewidth: 1
            })
            momentumGeo.vertices.push(node.atom.position)
            momentumGeo.vertices.push(node.getMomentum())
            var momentumLine = new THREE.LineSegments(momentumGeo, lineMaterial);
            momentumLine.name = "momentum";
            momentumLine.visible = false

            scene.add(momentumLine)

            // add the bond 
            node.edges.forEach(function(edge) {
                // set up the bond
                if (edge.getVisited() == false) {
                    var lineGeo = new THREE.Geometry()
                    var lineMaterial = new THREE.LineBasicMaterial({
                        color: parameters.color.bond,
                        linewidth: parameters.bondwidth
                    })

                    lineGeo.vertices.push(edge.atom1.position)
                    lineGeo.vertices.push(edge.atom2.position)
                    var line = new THREE.LineSegments(lineGeo, lineMaterial);

                    line.name = "line:" + edge.atom1.aid + ":" + edge.atom2.aid

                    scene.add(line)
                    edge.setVisited()
                }
            })
        })
    }

   /************************************************************************************/
   /************************************************************************************/
   /************************** called when changing options  ***************************/
   /************************************************************************************/
   /************************************************************************************/

    function setupOptions() {

        var folder;
        var gui = new dat.GUI( { autoPlace: true, width: 320});

        // simulation controls
        folder = gui.addFolder("Simulation Controls");
        folder.add(options, "timestep", 0.01, 2.0, 0.01).name("Timestep (s)").onChange(render);

        // display controls
        folder = gui.addFolder("Display");

        // when one of the items is clicked, call the function setoptions.displayOption to swicth between different spaces
        // bind the menu to options.displayOption
        folder.add(options, "displayOption", ["position" , "momentum space", "energy space"]).name("Display").onChange(render);
 
        // when the option is checked / unchecked, call the responding function     
        // bind the menu to options["energy as opacity"] and options["momentum as vector"]
        folder.add(options, "energy as opacity").onChange(render);
        folder.add(options, "momentum as vector").onChange(render);

        // setup system
        folder = gui.addFolder("Setup System");

        // if the user changes the system, reset
        // bind the menu to options.systemOption
        folder.add(options, "systemOption", ["H2", "O2", "H2O"]).name("System").onChange(setupSystem); // render

        // reset the system
        var buttonReset = {
            resetSystem: function() {
                system.reset()
                settings.energyHistory = []
            }
        };
        folder.add(buttonReset, 'resetSystem').name("Reset System").onChange(render);

        gui.close();
    }

   /************************************************************************************/
   /************************************************************************************/
   /********************************* resize windows  **********************************/
   /************************************************************************************/
   /************************************************************************************/

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        camera.updateViewMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

   /************************************************************************************/
   /************************************************************************************/
   /********************************* mouse movement  **********************************/
   /************************************************************************************/
   /************************************************************************************/

   // handle which one is selected here
    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                SELECTED.position.copy(intersection.sub(offset));
            }
            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED)
                    INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                plane.setFromNormalAndCoplanarPoint(
                    camera.getWorldDirection(plane.normal),
                    INTERSECTED.position);
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex(parameters.color.selected);
            }
            container.style.cursor = 'pointer';

            document.getElementById('moleculeName').innerText = INTERSECTED.moleculeName

            var ids = INTERSECTED.name.split(":")
            var id = ids[1]
            var node = system.getNode(id)
            node.setPosition(INTERSECTED.position)

        } else {
            if (INTERSECTED)
                INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            container.style.cursor = 'auto';
            document.getElementById('moleculeName').innerText = ""
        }
    }

   /************************************************************************************/
   /************************************************************************************/
   /***************************** when mouse is pressed  *******************************/
   /************************************************************************************/
   /************************************************************************************/

    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object;
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                offset.copy(intersection).sub(SELECTED.position);
            }
            container.style.cursor = 'move';
        }
    }

   /************************************************************************************/
   /************************************************************************************/
   /***************************** when mouse is released  ******************************/
   /************************************************************************************/
   /************************************************************************************/

    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            SELECTED = null;
        }
        container.style.cursor = 'auto';
    }

   /************************************************************************************/
   /************************************************************************************/
   /***************************** request for the next frame  **************************/
   /************************************************************************************/
   /************************************************************************************/

    function animate() {
        setTimeout(function() {
            requestAnimationFrame(animate);
            render();
        }, 1000 / 25); // decrease the frame rate to 1000 / 25
    }

   /************************************************************************************/
   /************************************************************************************/
   /********** update the scene according to the different display types  **************/
   /************************************************************************************/
   /************************************************************************************/

    function updateScene() {
        var objects = scene.children

        objects.forEach(function(obj) {

            // if this is a node (atom)
            if (obj.type == "Mesh") {
                var ids = obj.name.split(":")
                var id = ids[1]
                var node = system.getNode(id)

                if(options.displayOption == "position"){
                    obj.position.x = node.position.x
                    obj.position.y = node.position.y
                    obj.position.z = node.position.z
                    obj.material.opacity = 1
                    obj.material.needsUpdate = true
                }
    
                // if (options.displayOption == "momentum space") {
                //      obj.material.opacity = 0.5
                //      obj.material.needsUpdate = true
                //      obj.material.transparent = true
                // }

              if (options.displayOption == "momentum space") {
                    obj.position.x = node.velocity.x * node.mass
                 	obj.position.y = node.velocity.y * node.mass
                    obj.position.z = node.velocity.z * node.mass
               }

                // opacity corresponds to energy
                // NOTE --- need to put up a legend on the side so the user knows what opacity corresponds to what energy (will be dynamic)
                if (options.displayOption == "energy space") {
                    if (node.maxEnergy != 0) {
                        // obj.material.opacity = 0.2 + 0.9 * node.energy / node.maxEnergy
                        obj.position.z = 0.2 + 0.9 * node.energy / node.maxEnergy
                    }
                    if (node.maxEnergy == 0) {
                        obj.material.opacity = 1
                    }
                }
               
               if(options["momentum as vector"]){
                    obj.material.opacity *= 0.9
               }
               
                obj.material.needsUpdate = true
                obj.material.transparent = true

            }


            // if this is a bond (line segments + not named as momentum)
            if (obj.type == "LineSegments" && obj.name != "momentum" ) {
                var ids = obj.name.split(":")
                var aid1 = ids[1],
                    aid2 = ids[2]
                var atom1 = scene.getObjectByName("atom:" + aid1)
                var atom2 = scene.getObjectByName("atom:" + aid2);
                var p1 = atom1.position,
                    p2 = atom2.position
                var dist = p1.distanceTo(p2)

                obj.geometry.vertices[0] = p1.clone()
                obj.geometry.vertices[1] = p2.clone()

                obj.geometry.verticesNeedUpdate = true

                obj.material.opacity = dist > parameters[options.systemOption].opacityThresholdScale ? 0 : (1 - dist / parameters[options.systemOption].opacityThresholdScale)
                obj.material.needsUpdate = true
                obj.material.transparent = true
            }

            // console.log
            if(options.displayOption != "momentum space" && obj.name == "momentum"){
                obj.visible = false
            }
            if(options.displayOption == "momentum space" && obj.name == "momentum"){
                obj.visible = true
                var id = obj.name.split(":")[1]
                var axis = obj.name.split(":")[2]
                if(axis == 'x'){
                    var node = system.getNode(id)
                    obj.geometry.vertices[0] = node.atom.position
                    obj.geometry.vertices[1] = node.getMomentumX()
                                                   .multiplyScalar(parameters[options.systemOption].momentumScale)
                                                   .add(node.atom.position) 
                    obj.geometry.verticesNeedUpdate = true
               }
               if(axis == 'y'){
                    var node = system.getNode(id)
                    obj.geometry.vertices[0] = node.atom.position
                    obj.geometry.vertices[1] = node.getMomentumY()
                                                   .multiplyScalar(parameters[options.systemOption].momentumScale)
                                                   .add(node.atom.position) 
                    obj.geometry.verticesNeedUpdate = true
               }
               if(axis == 'z'){
                    var node = system.getNode(id)
                    obj.geometry.vertices[0] = node.atom.position
                    obj.geometry.vertices[1] = node.getMomentumZ()
                                                   .multiplyScalar(parameters[options.systemOption].momentumScale)
                                                   .add(node.atom.position) 
                    obj.geometry.verticesNeedUpdate = true
               }
            }
        })
    }



    function drawEnergyHistory(){
        context.clearRect(0, 0, canvas.width, canvas.height);
        var maxEnergy = Math.max.apply(null, settings.energyHistory) // 4

        if (settings.energyHistory > 0)
            context.moveTo(0, canvas.height - canvas.height * settings.energyHistory[i] / maxEnergy);
        else
            context.moveTo(0, canvas.height);

        var x = 0,
            y = 0;
        context.beginPath();
        for (var i = 0; i < settings.energyHistory.length; i++) {
            x = i;
            if (maxEnergy == 0) {
                y = canvas.height - 1
            } else {
                y = canvas.height - 1 - (canvas.height - 2) * settings.energyHistory[i] / maxEnergy
            }
            context.lineTo(x, y);
        }
        context.stroke();
    }

   /************************************************************************************/
   /************************************************************************************/
   /************ called all the time when requesting for the next frame  ***************/
   /************************************************************************************/
   /************************************************************************************/

    function render() {
        drawEnergyHistory();

        settings.timeStep = options.timestep

        updateScene()
        controls.update();
        // only update forces and energies if an atom is not currently clicked on
        if (SELECTED != null) {
            system.selectID = SELECTED.name.split(':')[1]
            system.moveAtom(+system.selectID)
            system.setMaxEnergies()
        } else {
            // system energy
            settings.energyHistory.push(system.getEnergy())
            if (settings.energyHistory.length > settings.maxHistory) { // keep only 500 history
                settings.energyHistory.shift()
            }
            document.getElementById('energyVal').innerText = parseFloat(system.getEnergy()).toFixed(4);
            // forces & atom energy
            system.getForceAcc()
            system.updateNodes()
        }
        // console.log( camera.position)
         // camera.position.z -= 1
        var center = system.getCenter()
        // camera.position.x = center.x
        // camera.position.y = center.y
        renderer.render(scene, camera);
    }
    </script>
</body>

</html>
